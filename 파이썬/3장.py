# -*- coding: utf-8 -*-
"""3장

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ezgGreNEJ5_ZeEHwKDYj-e_V5kuAL0XM

파이썬의 내장 컬렉션 데이터 타입 : 셋 & 딕셔너리

파이썬의 셋은 반복 가능하고, 가변적, 중복 요소가 없고, 정렬되지 않은 컬렉션 데이터 타입/ 인덱스 연산은 할 수 없다.

셋은 멤버십 테스트 및 중복 항목 제거에 사용

A.add(x) -> 셋 A에 x가 없는 경우 x를 추가
"""

people={"버피","에인절","김종현"}
people.add("황민현")
people          #셋은 순서 상관 안씀

"""A.update(B) ->A를 B에 추가   / |="""

people={"버피","에인절","김종현"}
people.update({"황민현" , "최민기" , "강동호" ,"곽아론"})
people

people={"버피","에인절","김종현"}
people.update({"황민현" , "최민기" , "강동호" ,"곽아론"})
people |={"뉴이스트","러브"}
people

"""A.union(B) or A | B  -> update랑 같지만 연산 결과를 복사본으로 반환한다. -> 차이점이 피플을 하면 전체다 바뀌는게 아니고 복사본 원본은 안 바뀐다."""

people={"버피","에인절","김종현"}
people.union({"황민현","강동호","최민기"})

"""A.intersection(B) -> A & B 는 A와 B의 교집합의 복사본을 반환"""

people={"버피","에인절","김종현"}
vampires={"황민현","최민기","김종현"}
people.intersection(vampires)

people={"버피","에인절","김종현"}
vampires={"황민현","최민기","김종현"}
people & vampires

"""A.difference(B) or A - B -> A와 B의 차집합의 복사본을 반환"""

people={"버피","에인절","김종현"}
vampires={"황민현","최민기","김종현"}
people.difference(vampires)

people={"버피","에인절","김종현"}
vampires={"황민현","최민기","김종현"}
people-vampires

"""A.clear() -> A의 모든 항목을 제거한다."""

people={"버피","에인절","김종현"}
people.clear()
people

"""A.discard(x) -> A의 항목 x를 제거하며 반환값은 없다.

A.remove()는 제거하는건 같지만 항목 x가 없을 경우 keyerror 예외를 발생

A.pop() A에서 한 항목을 제거하고 그 항목을 반환한다, 셋이 비어있으면 에러를 발생
"""

countries={"한국","프랑스","영국"}
countries.pop()
countries.discard("영국")
countries.remove("한국")
countries.pop()

"""리스트 타입은 셋타입으로 변환가능 """

def remove_dup(l1):
    #리스트의 중복된 항목을 제거한 후 반환
    #셋은 중복된 값이 없다.
    return list(set(l1))

def intersection(l1,l2):
    #교집합 결과를 반환
    #리스트는 교집합,합집합 불가능 set으로 바꾼 뒤 교집합,합집합으로 쓰고 리스트로 마지막 반환
    return list(set(l1)&set(l2))

def union(l1,l2):
    #합집합 결과를 반환
    return list(set(l1) | set(l2) )

def test_sets_operations_with_lists():
    l1=[1,2,3,4,5,5,9,11,11,15]
    l2=[4,5,6,7,8]
    l3=[]
    assert(remove_dup(l1)==[1,2,3,4,5,9,11,15])
    assert(intersection(l1,l2)==[4,5])
    assert(union(l1,l2)==[1,2,3,4,5,6,7,8,9,11,15])
    assert(remove_dup(l3)==[])
    assert(intersection(l3,l2)==l3)
    assert(sorted(union(l3,l2))==sorted(l2))
    print("테스트 통과")

if __name__=="__main__":            #코랩에서는 이거 굳이 안써도 가능 
    test_sets_operations_with_lists()

"""딕셔너리도 셋 속성 사용가능"""

def set_operations_with_dict():
    pairs=[("a",1),("b",2),("c",3)]
    d1=dict(pairs)
    print("딕셔너리1\t : {0}".format(d1))
                                                                                                                                                                                                                                                                                                                                                           
    d2={"a":1, "c":2 , "d":3 , "e":4}
    print("딕셔너리1\t : {0}".format(d2))

    intersection=d1.keys() & d2.keys()
    print("d1 ∩ d2 (키)\t : {0}".format(intersection))

    intersection_items=d1.items() & d2.items()
    print("d1 ∩ d2 (키)\t : {0}".format(intersection_items))

    subtraction1=d1.keys() - d2.keys()
    print("d1 - d2 (키)\t : {0}".format(subtraction1))

    subtraction2=d2.keys() - d1.keys()
    print("d2 - d1 (키)\t : {0}".format(subtraction2))

    substraction_items=d1.items()-d2.items()
    print("d1 - d2 (키,값)\t : {0}".format(substraction_items))

    #딕셔너리의 특정 키를 제외한다.
    d3={key:d2[key] for key in d2.keys()-{"c","d"}}     #for문 한줄로 쓰기
    print("d2-{{c,d}}\t: {0}".format(d3))

if __name__=="__main__":
    set_operations_with_dict()

year=12
month=10
day=24
print(f'{year}년 {month}월 {day}일')

#f-string 포매팅 p53 !r없어도 가능

"""파이썬 딕셔너리는 해시 테이블로 구현, 해시 함수는 특정객체에 해당하는 임의의 정수 값을 상수 시간 내에 계산, 이 정수는 연관 배열의 인덱스로 사용"""

hash(42)

hash("hello")           #임의의 정수값 반환 / 예를 들어 %3을 할 때, 나머지가 0이 나오는 인덱스의 모음 /키-value의 의미랑 비슷

"""딕셔너리 in,len() 함수 가능 그리고 변경 가능해서 항목의 추가 및 제거 가능

매핑타입(키-값 항목의 컬렉션)인 딕셔너리는 반복 가능
"""

tarantino={}
tarantino['name']='쿠엔틴 티란티노'
tarantino['job']='감독'
tarantino

suunydale=dict({"name":'버피',"age":16,"hobby":"게임"})
suunydale

suunydale=dict(name='버피',age=6,hobby="게임")
suunydale

suunydale=dict([("name",'버피'),("age",16),("hobby","게임")])
suunydale

"""setdefault() -> 딕셔너리에서 키의 존재 여부를 모른 채 접근 할 대 사용된다
(딕셔너리에 존재하지 않은 키에 접근하면 예외가 발생)

A.setdefault(key,default) 를 사용하면 딕셔너리 A에 key가 존재할 경우 키에 해당하는 값을 얻을 수 있고, key가 존재하지 않는다면, 새 키와 기본값 default가 딕셔너리에 저장된다.
"""

def usual_dict(dict_data):
    #dict[key] 사용
    newdata={}      #빈 딕셔너리
    for k,v in dict_data:
        if k in newdata:
            newdata[k].append(v)        #k값과 v값을 병합               ...?
        else:
            newdata[k]=[v]              #딕셔너리 추가 키=k 값=[v]
    return newdata

def setdefault_dict(dict_data):
    #setdefault() 메서드 사용
    newdata={}      #빈 딕셔너리
    for k,v in dict_data:
        newdata.setdefault(k,[]).append(v)      #newdata에 k가 존재할 경우 []에 v를 넣어라
    return newdata

def test_setdef():
    dict_data=(("key1","value1"),("key1","value2"),("key2","value3"),("key2","value4"),("key2","value5"))
    print(usual_dict(dict_data))
    print(setdefault_dict(dict_data))

if __name__=="__main__":
    test_setdef()

"""A.update(B) -> 딕셔너리A에 딕셔너리 B의 키가 존재한다면 , 기존 A의 (키,값)을 B의 (키,값)으로 갱신한다. B의 키가 A에 존재하지 않는다면, B의 (키,값)을 A에 추가한다,"""

d={'a':1,"b":2}
d.update({"b":100})
d

d={'a':1,"b":2}
d.update({"b":2})
d

"""A.get(key) -> 딕셔너리 A의 key값을 반환. key가 존재하지 않으면 아무것도 반환 안함."""

sunnydale=dict(name="은혜",age=23,hobby="게임")
sunnydale.get("age")        #키 값이 없을 땐 아무것도 반환 안함.

sunnydale=dict(name="은혜",age=23,hobby="게임")
sunnydale['name']       #없을 땐 오류가 남.

"""items(),keys(),values() 메서드는 딕셔너리 뷰다. 딕셔너리 뷰란 딕셔너리의 항목을 조회하는 읽기 전용의 반복 가능한 객체다.
불변이라서 읽기만 가능하다.
반복문에는 사용가능->반복 가능한 객체이니깐 
"""

sunnydale=dict(name="은혜",age=23,hobby="게임")
sunnydale.items()           #키와 값 둘다

sunnydale=dict(name="은혜",age=23,hobby="게임")
sunnydale.values()      #값만

sunnydale=dict(name="은혜",age=23,hobby="게임")
sunnydale.keys()        #키의 값만
type(sunnydale.keys())

sunnydale=dict(name="은혜",age=23,hobby="게임")
sunnydale["address"]="대구"
sunnydale                       #추가방법

"""A.pop(key)는 딕셔너리 A의 key항목을 제거한 후, 그 값을 반환

A.popitems() 딕셔너리 A에서 항목(키와 값)을 제거한 후, 그 키와 항목을 반환
"""

suunydale={'address': '대구', 'age': 23, 'hobby': '게임', 'name': '은혜'}
sunnydale.pop('hobby')        #키값을 입력

suunydale={'address': '대구', 'age': 23, 'hobby': '게임', 'name': '은혜'}
suunydale.popitem()             #아무것도 안 입력

"""clear() -> 모든 항목을 제거한다,"""

sunnydale.clear()
sunnydale

"""**3.2.2 딕셔너리 성능 측정**
딕셔너리를 벤치마킹 데스트하여 성능을 측정, 다음 코드는 리스트와 딕셔너리의 멤버십 연산을 테스트한다. 멤버십 연산에 대한 시간복잡도는 리스트느 0(n)안 반면, 딕셔너리는 0(1)이다. 
"""

import timeit
import random

for i in range(10000,1000001,20000):            #10000 이상 1000000까지 20000개 차이 
    t=timeit.Timer("random.randrange(%d) in x" %i,"from __main__ import random,x")
    x=list(range(i))    #리스트
    lst_time=t.timeit(number=1000)  
    x={j:None for j in range(i)}        #딕셔너리
    d_time=t.timeit(number=1000)
    print("%d,%10.3f,%10.3f" %(i,lst_time,d_time))

    #list보다는 딕셔너리가 더 빠르게 된다./ True,False 반응 속도 알아보기

"""**3.2.3 딕셔너리 순회**
딕셔너리 순회할때 sorted() 함수 사용 
"""

d= dict(c="!",b="world",a="hello")
for key in sorted(d.keys()) :       #d.keys(): 키 값 다 
    print(key,d[key])           #d[key]-> 그 키 값에 해당하는 값

"""**3.2.4 딕셔너리 분기**"""

def hello():
    print("hello")

def world():
    print("world")

action="h"

if action=="h":
    hello()
elif action=="w":
    world()

action="h"

functions=dict(h=hello,w=world)
functions[action]()                 #키-값으로 설정한 후, 실행