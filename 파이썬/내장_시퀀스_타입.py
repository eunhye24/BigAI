# -*- coding: utf-8 -*-
"""내장 시퀀스 타입

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WLH048j86uAw2IitGiC8I1xO-Xew5A66

파이썬에는 문자열,튜플,리스트,바이트 배열,바이트 등 5개의 내장 시퀀스 타입이 있다.
"""

l=[]
type(l)  #리스트 ->가변 객체 타입

s=" "
type(s) #문자열->불변 객체 타입

t=()
type(t) #튜플 ->불변 객체 타입

ba=bytearray(b"")
type(ba) #바이트배열 ->불변 객체 타입

b=bytes([])
type(b) #바이트 ->가변 객체 타입

"""일반적으로 불변 객체 타입은 가변 보다 효율적/ 또한 일부 컬렉션 데이터 타입 (셋,딕셔너리)은 불변 데이터 타입으로 인덱싱할 수 있다."""

myList=[1,2,3,4]
newList=myList[:] #전부다 복사한다는 의미
newList2=list(myList) #리스트의 깊은 복사

people={"톰","민수","진수"}
slayers=people.copy() #복사
slayers.discard("톰") #톰을 삭제
slayers.remove("민수") #민수를 삭제
print(slayers)
print(people) #셋의 깊은 복사

myDict={"안녕":"세상"}
newDict=myDict.copy()
print(newDict) #딕셔너리 깊은 복사

"""기타 객체의 깊은 복사를 할 때는 copy모듈 사용"""

import copy

myObj="다른 어떤 객체"
newObj=copy.copy(myObj) #얕은 복사
newObj2=copy.deepcopy(myObj) #깊은 복사

"""슬라이싱 연산자 
sep[시작]
sep[시작:끝]
sep[시작:끝:스텝]

오른쪽부터 읽고 싶으면 인덱스를 음수로 나타 낼 수 있다.
"""

word="뱀파이어를 조심해!"
print(word[-1])
print(word[-2])
print(word[-2:])
print(word[0:3])
print(word[:-2])
print(word[-0])  #인덱스 시작은 0부터 끝은 -1까지

"""문자열은 str타입을 사용

유니코드는 전 세계 언어의 문자를 정의하기 위한 국제 표준 코드
유니코드는 공백,특수문자,수학 및 기타 분야의 기호들도 포함
파이썬 3부터 모든 문자열은 일반적인 바이트가 아닌 유니코드임. 
문자열 앞에 u를 붙이면 유니코드 문자열을 만들 수 있음
"""

u"잘가\u0020세상 !" #이스케이프 시퀀스는 서수 값이 0x0020인 유니코드 문자를 나타냄
#유니코드표현 -> 16비트 /아스키 코드 표현-> 7비트

"""**<문자열 메서드>**

---

A.join(B) 는 리스트 B에 있는 모든 문자열을 하나의 단일 문자열 A로 결합한다
+로 결합가능 하지만 리스트에 많은 양의 문자열이 있으면 비효율적
"""

slayers=["버피","앤","아스틴"]
" ".join(slayers)

slayers=["버피","앤","아스틴"]
"--<>--".join(slayers)

slayers=["버피","앤","아스틴"]
"".join(slayers)

slayers=["버피","앤","아스틴"]
"".join(reversed(slayers)) #reversed는 순서 뒤로 오른쪽 부터 출력

"""A.ljust(width,fillchar) 는 문자열 A '맨 처음'부터 문자열을 포함한 길이 width만큼 문자 fillchar를 채운다.

A.rjust(width,fillchar)는 문자열 A '맨 끝'부터 문자열을 포함한 길이 width만큼 문자 fillchar를 채운다,
"""

name="스칼렛"
name.ljust(10,"-")

name="스칼렛"
name.rjust(10,"-")

"""A.format() 는 문자열 A에 변수를 추가하거나 형식화하는데 사용"""

"{0} {1}".format("안녕,","파이썬!")  #0부터 시작 /안적어도 가능 -> 필드이름이나 인덱스 생략 가능

"이름:{who},나이:{age}".format(who="제임스",age=22)

"이름:{who},나이:{0}".format(17,who="로미오")

"{} {} {}".format("파이썬","자료구조","알고리즘")

import decimal

"{0} {0!s} {0!r} {0!a}".format(decimal.Decimal("99.9")) #s는 문자열 형식
#r은 표현 형식  Q.표현형식이 뭘까? A. 파이썬 인터프리터에서 사용하는 문자열,보통 디버깅할때 사용/a는 아스키코드형식

"""문자열 언패킹 -> 연산자는 **임 이걸 사용하면 함수로 전달하기에 적합한 키-값 딕셔너리가 생성 

locals() 매소드는 현재 스코프에 있는 지역 변수를 딕셔너리로 반환
"""

hero="비버"
number=100
"{number}: {hero}".format(**locals())

"""A.splitlines()는 문자열 A에 대해 줄 바꿈 문자를 기준으로 분리한 결과를 문자열 리스트로 반환"""

slayers="로미오\n줄리엣"
slayers.splitlines()

"""A.split(t,n)는 문자열 A에서 문자열 t를 기준으로 정수 n번 만큼 분리한 문자열 리스트를 반환 n을 지정하지 않으면 대상 문자열을 t로 최대한 분리
t도 지정하지 않은면 공백문자로 구분한 문자열 리스트를 반환
"""

slayers="버피*크리스-메리*16"
fields=slayers.split("*")
fields

slayers="버피*크리스-메리*16"
fields=slayers.split("*")
jobs=fields[1].split("-")
jobs

def erase_space_from_string(string): 
    s1=string.split(" ")
    s2="".join(s1)
    return s2                           #문자열에서 모든 스페이스를 제거하는 함수

def erase_space_from_string(string): 
    s1=string.split(" ")
    s2="".join(s1)
    return s2                           #문자열에서 모든 스페이스를 제거하는 함수

erase_space_from_string("안녕 내 이름은 미자야")    #함수 사용

start="안녕*세상*!"
start.split("*",1)          #*을 기준으로 1번 짜르기

""".rsplit(t,n) 메서드는 split(t,n) 메서드와 같은 방식으로 문자열을 오른쪽에서 왼쪽으로 분리한 문자열 리스트를 반환 (어느쪽에서 시작하는냐에 다름)"""

start="안녕*세상*!"
start.rsplit("*",1)

"""A.strip(B)는 문자열A 앞뒤의 문자열B를 제거한다. 인수B가 없으면 공백 문자를 제거한다."""

slayers="로미오 & 줄리엣777"
slayers.strip("777")

# 비상상태!!!!! 이거 이해를 못함,,


import string 
import sys      #파이썬 인터프리터를 제어할 수 있는 방법을 제공

def count_unique_word():
    words={}
    strip=string.whitespace + string.punctuation + string.digits + "\"'"  #Q.이것의 의미는 무엇인가 모든 문자를 없애는건가?
    for filename in sys.argv[1:]:   #sys.argv[1:]의 의미는 무엇인가?
        with open(filename) as file:    #open(filename, mode):파일 열기
            for line in file:
                for word in line.lower().split(): #소문자
                    word=word.strip(strip)
                    if len(word)>2:
                        words[word]=words.get(word,0)+1     #.get(키값,아니면이값)->딕셔너리 값 가져오기

    for word in sorted(words):          #sorted(정렬할 값,내림차순할거면 reverse=True해야함/안적으면 오름차순)-> 정렬함수 
        print("{0}: {1}번".format(word,words[word]))

if __name__=="__main__":
    count_unique_word()        
    
     #strip메서드를 사용하여, 한 파일에서 사용된 모든 단어를 알파벳순으로 출력하며 각 단어가 등장한 횟수 출력

    #string.whitespace : 공백으로 간주하는 모든 ASCII(아스키 코드) 문자를 포함하는 문자열. 여기에는 스페이스, 탭, 줄 바꿈, 캐리지 리턴, 세로 탭 및 폼 피드 문자가 포함됩니다.
    #string.punctuation : C 로케일에서 구두점 문자로 간주하는 ASCII 문자의 문자열: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~.
    #string.digits: 문자열 '0123456789'
    #sys.argv : 파이썬 명령행 인자 받기
    #argv[0]에는 실행하는 스크립트의 경로가 담겨 있고, argv 배열의 1번째 원소부터 인자로 전달되는 값들을 저장하고 있습니다. 
    #sys.argv: 실행파일의 경로 / sys.argv[1]: 프로그램의 실행옵션

"""A.lstrip(chars) : 문자열A의 시작(왼쪽)부분에 있는 문자열 chars 또는 공백을 제거

A.rstip(chars) : 문자열A의 오른쪽 부분에 있는 chars 또는 공백을 제거
"""

name="**엠마 왓슨**"
name.lstrip("*")

name="**엠마 왓슨**"
name.rstrip("*")

"""A.swapcase()는 문자열A에서 대소문자를 반전한 문자열의 복사본을 반환"""

slayers="Buffy and Faith"
slayers.swapcase()

"""A.capitalize() 메서드는 문자열 첫 글자를 대문자로

lower() 메서드는 전체 문자열을 소문자로 

upper() 메서드는 전체 문자열을 대문자로 변경 
"""

slayers="buffy and Faith"
slayers.capitalize()

slayers="buffy and Faith"
slayers.lower()

slayers="buffy and Faith"
slayers.upper()

"""A.index(sub,start,end)는 문자열 A에서 부분 문자열 sub의 인덱스 위치를 반환하며 실패하면 ValueError 예외를 발생시킴

A.find(sub, start, end)는 문자열A에서 부분 문자열 sub의 인덱스 위치를 반환, 실패하면 -1을 반환 

인덱스 start와 end는 문자열 범위이며, 생략할 경우 전체 문자열에서 부분열 sub을 찾음
"""

slayers="Buffy and Faith"
slayers.find("y") #0부터 시작

slayers="Buffy and Faith"
slayers.find("k")   #오류

slayers="Buffy and Faith"
slayers.index("k")  #index 오류

slayers="Buffy and Faith"
slayers.index("y")

"""rindex(sub,start,end) -> 오른쪽부터 일치하는 부분 인덱스를 반환

rfind(sub,start,end) -> 오른쪽부터 

오류는 index,find 각각 일치
"""

slayers="Buffy and Faith"
slayers.rindex("a")         #인덱스 그건 원래대로 인데 찾는문자를 오른쪽부터

slayers="Buffy and Faith"
slayers.rfind("a")

"""A.count(sub,atart,end)는 문자열 A에서 인덱스 start,end 범위 내의 부분 문자열 sub가 나온 횟수 반환"""

slayer="Buffy is Buffy is Buffy"
slayer.count("Buffy",0,-1)

slayer="Buffy is Buffy is Buffy"
slayer.count("Buffy")

slayer="Buffy is Buffy is Buffy"
slayer.count("Buffy",0,5)

"""A.replace(old,new,maxreplace)는 문자열 A에서 문자열 old를 대체 문자열 new로 maxreplce만틈 변경한 문자열의 복사본을 반환 maxreplace를 지정하지 않으면 모든 old를 new로 변경"""

slayer="Buffy is Buffy is Buffy"
slayer.replace("Buffy","who",2)

"""f-strigs -> 문자열 앞에 접두사 f를 붙이면 사용가능 기존 %나 format방식에 비해 간결하고 직관적이고 속도 빠름"""

name="프레드"
f"그의 이름은 {name!r}입니다."  #!r은 표현형식
print(repr(name)) #' ' 있음 그냥 할 경우 없음

name="프레드"
f"그의 이름은 {repr(name)}입니다."  #repr은 !r 과 같음
#결과값을 변수에 넣을 수 있다. 문자열은 못넣음

import decimal

width=10
precision=4

value=decimal.Decimal("12.34567")
f"결과 : {value:{width}.{precision}}"    #중첩 필드 사용        #->이거 그 안에 value의미를 모르겠다 ,,
#총 10칸이 있는데 4개를 써라

from datetime import datetime

today=datetime(year=2017,month=1,day=27)
f"{today:%B %d %Y} "    #날짜 포맷 지정 지정자(specifier) 사용 
#%B:영어 월,%d:일, %Y:네자리수 연도

number=1024
f"{number:#0x}" #정수 포맷 지정자 사용 (16진수 표현)

"""튜플은 쉼표로 구성된 값으로 이루어지는 불변 시퀸스 타입이다."""

t1=1234,"안녕"
t1[0]

t1=1234,"안녕"
t1

t1=1234,"안녕"
t2=t1,(1,2,3,4,5)   #중첩됨(nested)
t2

"""문자열에서 각 위치에 단일 문자가 있는 것처럼, 튜플은 각 위치에 객체 참조를 갖는다. 리스트와 같이 변경 가능한 객체를 포함하는 튜플을 만들 수 있다.

빈튜플은 괄호 쌍으로 생성할 수 있다.
튜플은 값과 쉼표를 사용해 생성한다( 괄호 안에 쉼표 없이 값 하나만 넣으면 튜플이 생성안됨)
"""

empty=()
t1="안녕", #또는 ("안녕",) 도 가능
len(empty)

t1="안녕", #또는 ("안녕",) 도 가능
len(t1)

t1="안녕", #또는 ("안녕",) 도 가능
t1

t2=("안녕")
t2      #쉼표가 없으므로 튜플 생성안됨.

"""**<튜플 메서드>**

---



A.count(x) 튜플 A에 담긴 항목 x의 개수를 반환

index(x) 메서드는 항목 x의 인덱스 위치를 반환
"""

t=1,5,7,8,9,4,1,4
t.count(4)

t=1,5,7
t.index(5)

"""<튜플 언패킹>

파이썬에서 모든 반복 가능한 객체는 시퀀스 언패킹 연산자 *를 사용하여 언패킹 가능
변수를 할당하는 문장에서 왼쪽에 두 개 이상의 변수를 사용하고 한 변수 앞에 * 연산자가 붙으면, 오른쪽 값들 중 할당되고 남은 값들이 * 연산자가 붙은 변수에 할당
"""

x,*y=(1,2,3,4)
x       #얘는 한개만 받나봐?

x,*y=(1,2,3,4)
y   #리스트 형식? 문자열은 딕셔너리 형식?
#변수명 앞에 * 표시를 하면 여러 개의 값을 갖는 리스트가 됩니다.

*x,y=(1,2,3,4)
x

*x,y=(1,2,3,4)
y

*x,y=(1,2,3,4,5)
x

a, b, *c = (1, 2, 3, 4, 5)
print(c)
print(a)
print(b)

"""네임드 튜플 : 일반 튜플과 비슷한 성능과 특성을 갖지만, 튜플 항목을 인덱스 위치뿐만아니라 이름으로도 참조 가능

collections.namedtuple()->메서드의 첫 번째 인수는 만들고자 하는 사용자 정의 튜플 데이터 타입의 이름이다.( 보통 왼쪽에 할당하는 변수의 이름과 똑같이 사용)
두 번째 인수는 사용자 정의 튜플 각 항목을 지정하는 '공백으로 구분된 문자열'이다.(리스트 또는 튜플로 지정 가능)
"""

import collections
person=collections.namedtuple("person","name age gender")
#person=collections.namedtuple("person",["name","" age","" gender"])    리스트로도 지정 가능
#person=collections.namedtuple("person",("name","" age", "gender"))     튜플로도 지정 가능
p=person("아스틴","30","남")
p

import collections
person=collections.namedtuple("person","name age gender")
#person=collections.namedtuple("person",["name","" age","" gender"])    리스트로도 지정 가능
#person=collections.namedtuple("person",("name","" age", "gender"))     튜플로도 지정 가능
p=person("아스틴","30","남")
p[0]

import collections
person=collections.namedtuple("person","name age gender")
#person=collections.namedtuple("person",["name","" age","" gender"])    리스트로도 지정 가능
#person=collections.namedtuple("person",("name","" age", "gender"))     튜플로도 지정 가능
p=person("아스틴","30","남")
p[1]=20     #에러: 일반 튜플과 마찬가지로 불변형이다. 가변형은 리스트와 바이트